{"posts":[{"title":"CF1073G Yet Another LCP Problem","text":"还算有点意思。 把原字符串倒过来建一个 SAM，则我们熟知两个后缀的 LCP 就是其对应节点在 link 树上 LCA 的 len 值。 然后考虑 DP。这类问题的普遍套路是钦定某一个点是 LCA 然后对每个点计算贡献。我们设 表示 子树内属于集合 的点的个数， 表示 子树内属于集合 的点的个数，显然一对合法的点的 LCA 是 当且仅当它们在 的不同子树中，因此，我们便有如下方程： 直接做会退化成 ，但考虑到 及 的量级都为 ，因此我们可以考虑建出虚树然后再 DP，这样复杂度就对了。 注意清空虚树的邻接表以及 与 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;bits/stdc++.h&gt;using i64 = long long;using u32 = unsigned;template &lt;typename T = int&gt;inline T read() { T res; std::cin &gt;&gt; res; return res;}constexpr int N = 4e5 + 50;int n, m;char s[N];int pos[N];struct SAM { int ch[N][26], link[N], len[N], cnt = 1, lst = 1; int expand(int d) { int cur = ++cnt; len[cur] = len[lst] + 1; int p = lst; for (; p &amp;&amp; !ch[p][d]; p = link[p]) ch[p][d] = cur; if (!p) { link[cur] = 1; } else { int q = ch[p][d]; if (len[p] + 1 == len[q]) { link[cur] = q; } else { int tmp = ++cnt; len[tmp] = len[p] + 1, link[tmp] = link[q]; memcpy(ch[tmp], ch[q], sizeof(ch[q])); for (; p &amp;&amp; ch[p][d] == q; p = link[p]) ch[p][d] = tmp; link[cur] = link[q] = tmp; } } return lst = cur; }} sam;std::vector&lt;int&gt; adj[N];namespace LCA {int dfn[N], clk;int st[20][N];void dfs(int u, int frm) { st[0][dfn[u] = ++clk] = frm; for (auto v : adj[u]) { if (v == frm) continue; dfs(v, u); } }inline int cmp(int u, int v) { return dfn[u] &lt; dfn[v] ? u : v; }void init() { dfs(1, 0); for (int i = 1; i &lt;= std::__lg(clk); i++) { for (int j = 1; j &lt;= clk - (1 &lt;&lt; i) + 1; j++) { st[i][j] = cmp(st[i - 1][j], st[i - 1][j + (1 &lt;&lt; (i - 1))]); } }}inline int queryLCA(int u, int v) { if (u == v) return u; u = dfn[u], v = dfn[v]; if (u &gt; v) std::swap(u, v); int d = std::__lg(v - u++); return cmp(st[d][u], st[d][v - (1 &lt;&lt; d) + 1]);}} // namespace LCAusing LCA::queryLCA, LCA::dfn;std::vector&lt;int&gt; vadj[N];int stk[N], top;i64 f[N], g[N], ans;void dp(int u) { int hav = f[u], len = sam.len[u]; // hav == 1 means there is a point in u for (auto v : vadj[u]) dp(v), f[u] += f[v], g[u] += g[v]; for (auto v : vadj[u]) ans += f[v] * (g[u] - g[v]) * len; ans += hav * g[u] * len;}void solve() { std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; (s + 1); for (int i = n; i &gt;= 1; i--) pos[i] = sam.expand(s[i] - 'a'); for (int i = 2; i &lt;= sam.cnt; i++) adj[sam.link[i]].push_back(i); LCA::init(); for (int k, l, u; m; m--) { std::cin &gt;&gt; k &gt;&gt; l; std::vector&lt;int&gt; t; while (k--) t.push_back(pos[u = read()]), f[pos[u]]++; while (l--) t.push_back(pos[u = read()]), g[pos[u]]++; std::sort(t.begin(), t.end(), [&amp;](int lhs, int rhs) { return dfn[lhs] &lt; dfn[rhs]; }); t.erase(std::unique(t.begin(), t.end()), t.end()); u32 siz = t.size(); for (u32 i = 1; i &lt; siz; i++) t.push_back(queryLCA(t[i - 1], t[i])); std::sort(t.begin(), t.end(), [&amp;](int lhs, int rhs) { return dfn[lhs] &lt; dfn[rhs]; }); t.erase(std::unique(t.begin(), t.end()), t.end()); stk[top = 1] = t[0]; for (u32 i = 1; i &lt; t.size(); i++) { while (queryLCA(t[i], stk[top]) != stk[top]) top--; vadj[stk[top]].push_back(t[i]), stk[++top] = t[i]; } ans = 0, dp(t[0]); std::cout &lt;&lt; ans &lt;&lt; \"\\n\"; for (auto i : t) vadj[i].clear(), f[i] = g[i] = 0; }}int main() { std::cin.tie(nullptr)-&gt;sync_with_stdio(false); int t = 1; // std::cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2024/01/21/CF1073G-Yet-Another-LCP-Problem/"},{"title":"P2178 [NOI2015] 品酒大会","text":"首先容易得知两个 相似的子串一定是 相似的，这是一个类似后缀包含的结构，我们可以很自然的联想到 SAM。 由于是后缀，因此我们考虑对反串建出 SAM，则容易知道两个后缀的最大相似度即为其对应节点在 link 树上的 LCA 的 len，也即是 LCP 的长度，根据经典套路我们可以考虑枚举 link 树上的每一个节点作为 LCA 来计算贡献。容易知道两个后缀的 LCP 对应节点为 时，后缀所对应的两个节点一定是分别位于 的不同子树内部的，因此很容易就能求出最大相似度为某一定值的后缀对数，又根据我们一开始得到的结论，我们只需要做一个后缀和就能得到相似度可以为某一个值的后缀对数。 再来考虑如何求最大值，根据上边的思路，我们只需要维护一棵子树内 的最大值、次大值、最小值、次小值即可求出答案，最后再做一个后缀 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using i64 = long long;constexpr int N = 1e6 + 50;int cnt[N];struct SAM { int ch[N][26], len[N], link[N], cnt = 1, lst = 1; int expand(char c) { int cur = ++cnt, d = c - 'a'; len[cur] = len[lst] + 1, ::cnt[cur] = 1; int p = lst; for (; p &amp;&amp; !ch[p][d]; p = link[p]) ch[p][d] = cur; if (!p) { link[cur] = 1; } else { int q = ch[p][d]; if (len[p] + 1 == len[q]) { link[cur] = q; } else { int tmp = ++cnt; len[tmp] = len[p] + 1, link[tmp] = link[q]; memcpy(ch[tmp], ch[q], sizeof(ch[tmp])); for (; p &amp;&amp; ch[p][d] == q; p = link[p]) ch[p][d] = tmp; link[cur] = link[q] = tmp; } } return lst = cur; }} sam;int n, a[N];char s[N];std::vector&lt;int&gt; adj[N];i64 sum[N];int mx[N], smx[N], mn[N], smn[N]; // `s` stands for `semi`i64 ans[N];inline void chkmax(int u, int w) { if (w &gt;= mx[u]) smx[u] = mx[u], mx[u] = w; else if (w &gt; smx[u]) smx[u] = w;}inline void chkmin(int u, int w) { if (w &lt;= mn[u]) smn[u] = mn[u], mn[u] = w; else if (w &lt; smn[u]) smn[u] = w;}void dfs(int u) { int t = 0; for (auto v : adj[u]) { dfs(v), t += cnt[v]; chkmax(u, mx[v]), chkmax(u, smx[v]); chkmin(u, mn[v]), chkmin(u, smn[v]); } if (t + cnt[u] &lt; 2) return cnt[u] += t, void(); i64 &amp;p = ans[sam.len[u]]; p = std::max({p, 1ll * mx[u] * smx[u], 1ll * mn[u] * smn[u]}); for (auto v : adj[u]) { sum[sam.len[u]] += 1ll * cnt[u] * cnt[v]; cnt[u] += cnt[v]; }}void solve() { memset(mx, -0x3f, sizeof(mx)), memset(smx, -0x3f, sizeof(mx)); memset(mn, 0x3f, sizeof(mn)), memset(smn, 0x3f, sizeof(mn)); memset(ans, -0x3f, sizeof(ans)); std::cin &gt;&gt; n &gt;&gt; (s + 1); for (int i = 1; i &lt;= n; i++) std::cin &gt;&gt; a[i]; for (int i = n; i &gt;= 1; i--) { int p = sam.expand(s[i]); mx[p] = mn[p] = a[i]; } for (int i = 2; i &lt;= sam.cnt; i++) adj[sam.link[i]].push_back(i); dfs(1); for (int i = n - 1; ~i; i--) { sum[i] += sum[i + 1]; ans[i] = std::max(ans[i], ans[i + 1]); } for (int i = 0; i &lt; n; i++) { std::cout &lt;&lt; sum[i] &lt;&lt; \" \" &lt;&lt; (sum[i] ? ans[i] : 0) &lt;&lt; \"\\n\"; }}signed main() { std::cin.tie(nullptr)-&gt;sync_with_stdio(false); int t = 1; // std::cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2024/01/22/P2178-NOI2015-%E5%93%81%E9%85%92%E5%A4%A7%E4%BC%9A/"},{"title":"P2414 [NOI2011] 阿狸的打字机","text":"题意类似多模式串匹配，因此我们考虑建出 AC 自动机，然后离线下来，将询问挂到文本串对应的 AC 自动机的节点上。 然后就很好做了，我们考虑对 fail 树进行 DFS，容易得到模式串被文本串匹配的次数就是文本串对应的节点位于模式串末尾节点子树内部的个数，这个我们直接用 BIT 处理即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using i64 = long long;using pii = std::pair&lt;int, int&gt;;constexpr int N = 2e5 + 50;std::string s;int m;std::vector&lt;pii&gt; qry[N];struct ACAM { int ch[N][26], nxt[N], cnt, fa[N], end[N], to[N]; int tr[N][26]; void eval(const std::string_view &amp;s) { int p = 0, sc = 0; for (auto c : s) { if (c == 'B') { p = fa[p]; } else if (c == 'P') { end[p] = ++sc, to[sc] = p; } else { if (!ch[p][c - 'a']) ch[p][c - 'a'] = ++cnt; fa[ch[p][c - 'a']] = p, p = ch[p][c - 'a']; } } } void build() { std::queue&lt;int&gt; q; for (int i = 0; i &lt; 26; i++) { if (ch[0][i]) q.push(ch[0][i]); tr[0][i] = ch[0][i]; } while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; 26; i++) { int &amp;v = ch[u][i]; tr[u][i] = v; if (!v) v = ch[nxt[u]][i]; else nxt[v] = ch[nxt[u]][i], q.push(v); } } }} ac;int dfn[N], siz[N], clk;std::vector&lt;int&gt; adj[N];inline int in(int u) { return dfn[u]; }inline int out(int u) { return dfn[u] + siz[u] - 1; }void dfs(int u) { dfn[u] = ++clk, siz[u] = 1; for (auto v : adj[u]) dfs(v), siz[u] += siz[v];}struct BIT { int tree[N]; void modify(int u, int val) { for (int i = u; i &lt;= clk; i += i &amp; -i) tree[i] += val; } int query(int u) { int res = 0; for (int i = u; i; i -= i &amp; -i) res += tree[i]; return res; } int query(int l, int r) { return query(r) - query(l - 1); }} bit;int ans[N];void calc(int u) { bit.modify(dfn[u], 1); if (ac.end[u]) { for (auto [x, i] : qry[ac.end[u]]) { ans[i] = bit.query(in(ac.to[x]), out(ac.to[x])); } } for (int i = 0; i &lt; 26; i++) { if (!ac.tr[u][i]) continue; calc(ac.tr[u][i]); } bit.modify(dfn[u], -1);}void solve() { std::cin &gt;&gt; s; ac.eval(s), ac.build(); for (int i = 1; i &lt;= ac.cnt; i++) adj[ac.nxt[i]].push_back(i); dfs(0); std::cin &gt;&gt; m; for (int i = 1, x, y; i &lt;= m; i++) { std::cin &gt;&gt; x &gt;&gt; y; qry[y].emplace_back(x, i); } calc(0); for (int i = 1; i &lt;= m; i++) std::cout &lt;&lt; ans[i] &lt;&lt; &quot;\\n&quot;;}signed main() { std::cin.tie(nullptr)-&gt;sync_with_stdio(false); int t = 1; // std::cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2024/01/22/P2414-NOI2011-%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA/"},{"title":"P3346 [ZJOI2015] 诸神眷顾的幻想乡","text":"这东西天然构成一棵字典树，考虑建出广义 SAM 来做。 但是发现如果钦定某一个节点为根的话，则只能统计出从这个节点出发的所有串，并不能包含所有的串。但是我们注意到题目保证叶子数不超过 个，因此我们可以依次枚举每一个叶子节点作为字典树的根，然后将从这个节点出发的点全部都塞到广义 SAM 里边去，容易发现这样搞虽然可能会重，但一定不会漏，而我们求的是本质不同子串的数量，因此重复的串并不影响答案。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using i64 = long long;// 增量构造吧，直接拉出来不是很好写constexpr int N = 4e6 + 50;int n, c, a[N];std::vector&lt;int&gt; adj[N];int deg[N];struct GSAM { int ch[N][10], link[N], len[N], cnt = 1; int expand(int lst, int d) { int cur = ch[lst][d]; if (len[cur]) return cur; len[cur] = len[lst] + 1; int p = link[lst]; for (; p &amp;&amp; !ch[p][d]; p = link[p]) ch[p][d] = cur; if (!p) { link[cur] = 1; } else { int q = ch[p][d]; if (len[p] + 1 == len[q]) { link[cur] = q; } else { int tmp = ++cnt; len[tmp] = len[p] + 1, link[tmp] = link[q]; for (int i = 0; i &lt; c; i++) ch[tmp][i] = len[ch[q][i]] ? ch[q][i] : 0; for (; p &amp;&amp; ch[p][d] == q; p = link[p]) ch[p][d] = tmp; link[cur] = link[q] = tmp; } } return cur; } void build() { std::queue&lt;std::pair&lt;int, int&gt;&gt; q; for (int i = 0; i &lt; c; i++) if (ch[1][i]) q.emplace(1, i); while (!q.empty()) { auto [u, d] = q.front(); q.pop(), u = expand(u, d); for (int i = 0; i &lt; c; i++) if (ch[u][i]) q.emplace(u, i); } }} gsam;void dfs(int u, int frm, int p) { if (!gsam.ch[p][a[u]]) gsam.ch[p][a[u]] = ++gsam.cnt; p = gsam.ch[p][a[u]]; for (auto v : adj[u]) { if (v == frm) continue; dfs(v, u, p); }}void solve() { std::cin &gt;&gt; n &gt;&gt; c; for (int i = 1; i &lt;= n; i++) std::cin &gt;&gt; a[i]; for (int i = 1, u, v; i &lt; n; i++) { std::cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v), adj[v].push_back(u); deg[u]++, deg[v]++; } for (int i = 1; i &lt;= n; i++) if (deg[i] == 1) dfs(i, 0, 1); gsam.build(); i64 ans = 0; for (int i = 1; i &lt;= gsam.cnt; i++) ans += gsam.len[i] - gsam.len[gsam.link[i]]; std::cout &lt;&lt; ans &lt;&lt; \"\\n\";}signed main() { std::cin.tie(nullptr)-&gt;sync_with_stdio(false); int t = 1; // std::cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2024/01/22/P3346-ZJOI2015-%E8%AF%B8%E7%A5%9E%E7%9C%B7%E9%A1%BE%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1/"},{"title":"P4022 [CTSC2012] 熟悉的文章","text":"感觉完全没有黑啊？不知道怎么评出来的。 首先答案显然是可以二分的，我们考虑二分出一个答案之后怎么做。 对于这类问题我们是很容易建出 DP 的模型的。我们设 为 为当前已经决策到了第 个字符时所能得到的最大的段的总长。那么这个 DP 的转移就比较显然了。 可以注意到有两种决策。第一种是当前字符不被选入某一段中，那么就有 。另一种是将当前划入某一段中，枚举这一段的开头 ，则有 ，当然 是有选取范围的，设当前二分的答案为 ，且 在原串中最多往前匹配 位，则有 。这样就可以容易的做到 的时间复杂度了，其中 为当前询问字符串的长度。 考虑如何优化。容易发现，内层的 DP 是一个比较显然的滑动窗口的模型，因此我们直接套用一个单调队列来优化即可，这样 DP 部分就可以做到 了。 然后再来考虑怎么求这个 。这个当然是比较简单的，我们把原串组织成一棵广义 SAM，那么求 len 的过程就类似于使用 SAM 求 LCS 的过程，我们直接跳 link 树即可。这部分的时间复杂度为 的。 于是这样这道题就做完了！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using i64 = long long;constexpr int N = 2e6 + 50;int n, m;int f[N], g[N];struct GSAM { int ch[N][2], len[N], link[N], cnt = 1; int expand(int lst, int d) { int p = lst; if (int q = ch[p][d]) { if (len[p] + 1 == len[q]) { return q; } else { int tmp = ++cnt; len[tmp] = len[p] + 1, link[tmp] = link[q]; memcpy(ch[tmp], ch[q], sizeof(ch[tmp])); for (; p &amp;&amp; ch[p][d] == q; p = link[p]) ch[p][d] = tmp; link[q] = tmp; return tmp; } } int cur = ++cnt; len[cur] = len[p] + 1; for (; p &amp;&amp; !ch[p][d]; p = link[p]) ch[p][d] = cur; if (!p) { link[cur] = 1; } else { int q = ch[p][d]; if (len[p] + 1 == len[q]) { link[cur] = q; } else { int tmp = ++cnt; len[tmp] = len[p] + 1, link[tmp] = link[q]; memcpy(ch[tmp], ch[q], sizeof(ch[tmp])); for (; p &amp;&amp; ch[p][d] == q; p = link[p]) ch[p][d] = tmp; link[cur] = link[q] = tmp; } } return cur; } void match(std::string_view s) { int p = 1; for (int i = 1, cur = 0; i &lt;= int(s.length()); i++) { int d = s[i - 1] - '0'; while (p != 1 &amp;&amp; !ch[p][d]) p = link[p], cur = len[p]; if (ch[p][d]) p = ch[p][d], cur = std::min(cur + 1, len[p]); g[i] = cur; } }} gsam;std::string s;bool check(int u) { static int q[N], hd = 1, tl = 0; for (int i = 0; i &lt; u; i++) f[i] = 0; q[hd = tl = 1] = 0; for (int i = u; i &lt;= int(s.length()); i++) { f[i] = f[i - 1]; while (hd &lt;= tl &amp;&amp; f[i - u] - (i - u) &gt;= f[q[tl]] - q[tl]) tl--; q[++tl] = i - u; while (hd &lt;= tl &amp;&amp; q[hd] &lt; i - g[i]) hd++; if (hd &lt;= tl) f[i] = std::max(f[i], f[q[hd]] + i - q[hd]); } return f[s.length()] * 10u &gt;= s.length() * 9;}void solve() { std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1, lst = 1; i &lt;= m; i++, lst = 1) { std::cin &gt;&gt; s; for (auto c : s) lst = gsam.expand(lst, c - '0'); } for (int i = 1; i &lt;= n; i++) { std::cin &gt;&gt; s; int lo = 0, hi = s.length(), ans = 0; gsam.match(s); while (lo &lt;= hi) { int mid = (lo + hi) &gt;&gt; 1; if (check(mid)) lo = mid + 1, ans = mid; else hi = mid - 1; } std::cout &lt;&lt; ans &lt;&lt; \"\\n\"; }}signed main() { std::cin.tie(nullptr)-&gt;sync_with_stdio(false); int t = 1; // std::cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2024/01/21/P4022-CTSC2012-%E7%86%9F%E6%82%89%E7%9A%84%E6%96%87%E7%AB%A0/"},{"title":"PKUWC 2024 游记","text":"省流：打的一坨屎。不过我本来就是去旅游的，感觉还比较平衡！ 25 号上午 7:35 出发，坐动车前往重庆，不过中间在宜昌东站转了一次车，到重庆的时候已经是傍晚了。在动车上把《只有我不在的城市》看完了，感觉非常震撼，前边的节奏非常好，就是最后结局感觉还是有点仓促，是不是改成 24 集的话会好很多？总归还是感谢 ckain 的推荐！ 订的酒店有点阴间，离育才有大概二十分钟的脚程。 晚上一个人打车前往洪崖洞，然后跟 ckain 与 kernel_panic 体验了下重庆的 “微微辣” 火锅，非常震撼！ 然后就是 Day 1 了！ 上午开幕式，云浅坐在我旁边！第一次见到本人啊，感觉非常帅。 然后育才本校的 DaydreamWarrior 同学坐在我的比较靠右的位置，遂跟他一起离场。 开幕式搞完了之后还有拍照的环节。发现粥群群友 AlphaDrawer 站在我旁边遂交换徽章并收到了签名！ 然后试机，发现电脑配置非常厉害啊，不知道评测机咋样。 试机题据说多年没换过了，感觉没啥水平，因为既然我都会做，那这道题目的难度显然不会超过普及组 T3。 出来之后面到了 DitaMirika，老哥人真的很好啊！ 中午还碰到了 irris 跟 nalemy，多亏有老哥带我随机游走啊/ll，准备午休的时候还看到了可爱的 yinhee/se/se/se。 然后就是非常厉害的比赛啊。T1 写了 3 个小时，最后喜提一百分了。 比较厉害的是我 T1 的规律是在猜了两个多小时之后花十分钟写了个暴力打表之后一眼看出来的，写完之后我一直在怀疑我前两个多小时都干了些啥。不过还好不是省选，这也算是个很好的教训了吧！T3 没看懂，然后发现读懂题意就有 40 分了。T2 是神秘的 DP，感觉一股 atc 味，不过 11 分的暴力都没写，非常失败，主要是赛时一直在想高斯消元有关的做法，结果 1) 忘了板子怎么写了； 2) 这个做法本来就是假的，因为有很多自由元，根本算不了一点。 晚上聚餐！由于 Day 0 晚上是我去的 kernel_panic 那边，所以这天晚上换他们来我这边！顺便还邀请到了 DitaMirika 一起来！ 在万象城里随机游走，结果一直都没怎么找到吃饭的地方，最后选了一家烤肉店点了个四人套餐，感觉吃得还是挺饱的。这天晚上没有出钱，钱是 DitaMirika 的妈妈出的，唉太感谢了。 然后老哥貌似对湖北人都挺熟的，尤其是 hsy 那边的，感觉他比我们三个正经湖北人都熟啊！且还听到了 “我感觉上 IGM 不难” 的这种批话，狠狠膜拜了。zyz master when/ll，怨念啊，都是怨念。 晚上加训战地 5，然后发生了非常不好的事情：手机屏幕摔坏了。摔了之后还没啥感觉，只是有一部分断触点，结果第二天早上一看我草整个屏幕都黑了，根本用不了，直接要了我的半条老命。 Day 2 上午是讲座，P 这边的是有关编程语言的啊！感觉非常的有趣，我还是第一次知道 逻辑式编程 这个概念，后边的 代码标注 啥的感觉也挺有意思的。PPT 上的演示语言貌似是 Haskell，结束之后稍微看了下 Real World Haskell，感觉非常有意思！ 中午因为没手机，所以就一直粘着 DitaMirika，真是麻烦老哥了/wq。 下午比赛。T1 一开始一直在写神秘随机化，结果发现如果写的好的话只有最后一个包过不了！遂调参怒交 21 发。但最后随便写了个贪心居然过了？就是从和为 5 的一直贪到和为 9 的，然后随便写写就对了？然后开 T2，想了很久感觉一点思路都没有，于是把 18pts 的暴力写了，然后找规律写了个 的包，一共有 28pts，据说是大众分。开始 T3 的时候只剩一个小时了，由于我是 STL 苦手所以我最低档暴力就写了 30min，结果 15pts 的板子 Segment Tree Beats 没写完就结束了。 感觉总结下来，两天的比赛主要还是策略问题，尤其是第一天，我自认为按我的水平冲到大众分 151 是没有任何问题的，但是 T1 的策略失误直接导致时间上的大失败，最后暴力都没拼完。第二天相对比较正常，但是还是在 T2 上分配了过多的时间，导致 T3 15pts 没写完。 如果发挥正常的话是不是能上 300 啊？天知道啊，马后炮没有任何意义啊！只能说幸好不是省选，不然真就抱憾终生了。 晚上聚餐啊！一共十二个人，他们分别是： 因为没手机，所以只好一直粘着 DaydreamWarrior，好人一生平安/ll。 晚上正好碰到了粥的冬日前瞻直播，结果直接变成粥批同好会了，感觉跟他们交流会暴露我云玩的本质，根本插不进嘴。于是我们这桌就提前离场了。 晚上接着加训战地 5。感觉酒店网络的 ping 虽然高点，但是 loss 比较正常，玩起来还是可以接受的。 第二天早起回家了，还是动车，不过这次没有转车。在车上把《昨日之歌》看完了，据说原作是从 99 年连载到 15 年的漫画，感觉很厉害啊！不过感觉最后陆生跟小晴那一段还是有点仓促，而且陆生跟榀子看得确实，额，非常的折磨，不过总体上还是蛮厉害的感觉。到家的时候已经四点了。 徽章还有一堆没换，不过我没有 WC，估计是换不出去了。 徽章的照片等我回家再说。","link":"/2024/01/29/PKUWC-2024-%E6%B8%B8%E8%AE%B0/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/01/17/hello-world/"},{"title":"test","text":"Test File1234567#include &lt;iostream&gt;&lt;=&gt;===","link":"/2024/01/17/test/"}],"tags":[{"name":"String","slug":"String","link":"/tags/String/"},{"name":"SAM","slug":"SAM","link":"/tags/SAM/"},{"name":"虚树","slug":"虚树","link":"/tags/%E8%99%9A%E6%A0%91/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"ACAM","slug":"ACAM","link":"/tags/ACAM/"},{"name":"BIT","slug":"BIT","link":"/tags/BIT/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"游记","slug":"游记","link":"/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"test","slug":"test","link":"/tags/test/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Luogu","slug":"题解/Luogu","link":"/categories/%E9%A2%98%E8%A7%A3/Luogu/"},{"name":"Codeforces","slug":"题解/Codeforces","link":"/categories/%E9%A2%98%E8%A7%A3/Codeforces/"},{"name":"游记","slug":"游记","link":"/categories/%E6%B8%B8%E8%AE%B0/"},{"name":"Other","slug":"Other","link":"/categories/Other/"}],"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}