{"posts":[{"title":"CF1073G Yet Another LCP Problem","text":"还算有点意思。 把原字符串倒过来建一个 SAM，则我们熟知两个后缀的 LCP 就是其对应节点在 link 树上 LCA 的 len 值。 然后考虑 DP。这类问题的普遍套路是钦定某一个点是 LCA 然后对每个点计算贡献。我们设 表示 子树内属于集合 的点的个数， 表示 子树内属于集合 的点的个数，显然一对合法的点的 LCA 是 当且仅当它们在 的不同子树中，因此，我们便有如下方程： 直接做会退化成 ，但考虑到 及 的量级都为 ，因此我们可以考虑建出虚树然后再 DP，这样复杂度就对了。 注意清空虚树的邻接表以及 与 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;bits/stdc++.h&gt;using i64 = long long;using u32 = unsigned;template &lt;typename T = int&gt;inline T read() { T res; std::cin &gt;&gt; res; return res;}constexpr int N = 4e5 + 50;int n, m;char s[N];int pos[N];struct SAM { int ch[N][26], link[N], len[N], cnt = 1, lst = 1; int expand(int d) { int cur = ++cnt; len[cur] = len[lst] + 1; int p = lst; for (; p &amp;&amp; !ch[p][d]; p = link[p]) ch[p][d] = cur; if (!p) { link[cur] = 1; } else { int q = ch[p][d]; if (len[p] + 1 == len[q]) { link[cur] = q; } else { int tmp = ++cnt; len[tmp] = len[p] + 1, link[tmp] = link[q]; memcpy(ch[tmp], ch[q], sizeof(ch[q])); for (; p &amp;&amp; ch[p][d] == q; p = link[p]) ch[p][d] = tmp; link[cur] = link[q] = tmp; } } return lst = cur; }} sam;std::vector&lt;int&gt; adj[N];namespace LCA {int dfn[N], clk;int st[20][N];void dfs(int u, int frm) { st[0][dfn[u] = ++clk] = frm; for (auto v : adj[u]) { if (v == frm) continue; dfs(v, u); } }inline int cmp(int u, int v) { return dfn[u] &lt; dfn[v] ? u : v; }void init() { dfs(1, 0); for (int i = 1; i &lt;= std::__lg(clk); i++) { for (int j = 1; j &lt;= clk - (1 &lt;&lt; i) + 1; j++) { st[i][j] = cmp(st[i - 1][j], st[i - 1][j + (1 &lt;&lt; (i - 1))]); } }}inline int queryLCA(int u, int v) { if (u == v) return u; u = dfn[u], v = dfn[v]; if (u &gt; v) std::swap(u, v); int d = std::__lg(v - u++); return cmp(st[d][u], st[d][v - (1 &lt;&lt; d) + 1]);}} // namespace LCAusing LCA::queryLCA, LCA::dfn;std::vector&lt;int&gt; vadj[N];int stk[N], top;i64 f[N], g[N], ans;void dp(int u) { int hav = f[u], len = sam.len[u]; // hav == 1 means there is a point in u for (auto v : vadj[u]) dp(v), f[u] += f[v], g[u] += g[v]; for (auto v : vadj[u]) ans += f[v] * (g[u] - g[v]) * len; ans += hav * g[u] * len;}void solve() { std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; (s + 1); for (int i = n; i &gt;= 1; i--) pos[i] = sam.expand(s[i] - 'a'); for (int i = 2; i &lt;= sam.cnt; i++) adj[sam.link[i]].push_back(i); LCA::init(); for (int k, l, u; m; m--) { std::cin &gt;&gt; k &gt;&gt; l; std::vector&lt;int&gt; t; while (k--) t.push_back(pos[u = read()]), f[pos[u]]++; while (l--) t.push_back(pos[u = read()]), g[pos[u]]++; std::sort(t.begin(), t.end(), [&amp;](int lhs, int rhs) { return dfn[lhs] &lt; dfn[rhs]; }); t.erase(std::unique(t.begin(), t.end()), t.end()); u32 siz = t.size(); for (u32 i = 1; i &lt; siz; i++) t.push_back(queryLCA(t[i - 1], t[i])); std::sort(t.begin(), t.end(), [&amp;](int lhs, int rhs) { return dfn[lhs] &lt; dfn[rhs]; }); t.erase(std::unique(t.begin(), t.end()), t.end()); stk[top = 1] = t[0]; for (u32 i = 1; i &lt; t.size(); i++) { while (queryLCA(t[i], stk[top]) != stk[top]) top--; vadj[stk[top]].push_back(t[i]), stk[++top] = t[i]; } ans = 0, dp(t[0]); std::cout &lt;&lt; ans &lt;&lt; \"\\n\"; for (auto i : t) vadj[i].clear(), f[i] = g[i] = 0; }}int main() { std::cin.tie(nullptr)-&gt;sync_with_stdio(false); int t = 1; // std::cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2024/01/21/CF1073G-Yet-Another-LCP-Problem/"},{"title":"P4022 [CTSC2012] 熟悉的文章","text":"感觉完全没有黑啊？不知道怎么评出来的。 首先答案显然是可以二分的，我们考虑二分出一个答案之后怎么做。 对于这类问题我们是很容易建出 DP 的模型的。我们设 为 为当前已经决策到了第 个字符时所能得到的最大的段的总长。那么这个 DP 的转移就比较显然了。 可以注意到有两种决策。第一种是当前字符不被选入某一段中，那么就有 。另一种是将当前划入某一段中，枚举这一段的开头 ，则有 ，当然 是有选取范围的，设当前二分的答案为 ，且 在原串中最多往前匹配 位，则有 。这样就可以容易的做到 的时间复杂度了，其中 为当前询问字符串的长度。 考虑如何优化。容易发现，内层的 DP 是一个比较显然的滑动窗口的模型，因此我们直接套用一个单调队列来优化即可，这样 DP 部分就可以做到 了。 然后再来考虑怎么求这个 。这个当然是比较简单的，我们把原串组织成一棵广义 SAM，那么求 len 的过程就类似于使用 SAM 求 LCS 的过程，我们直接跳 link 树即可。这部分的时间复杂度为 的。 于是这样这道题就做完了！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using i64 = long long;constexpr int N = 2e6 + 50;int n, m;int f[N], g[N];struct GSAM { int ch[N][2], len[N], link[N], cnt = 1; int expand(int lst, int d) { int p = lst; if (int q = ch[p][d]) { if (len[p] + 1 == len[q]) { return q; } else { int tmp = ++cnt; len[tmp] = len[p] + 1, link[tmp] = link[q]; memcpy(ch[tmp], ch[q], sizeof(ch[tmp])); for (; p &amp;&amp; ch[p][d] == q; p = link[p]) ch[p][d] = tmp; link[q] = tmp; return tmp; } } int cur = ++cnt; len[cur] = len[p] + 1; for (; p &amp;&amp; !ch[p][d]; p = link[p]) ch[p][d] = cur; if (!p) { link[cur] = 1; } else { int q = ch[p][d]; if (len[p] + 1 == len[q]) { link[cur] = q; } else { int tmp = ++cnt; len[tmp] = len[p] + 1, link[tmp] = link[q]; memcpy(ch[tmp], ch[q], sizeof(ch[tmp])); for (; p &amp;&amp; ch[p][d] == q; p = link[p]) ch[p][d] = tmp; link[cur] = link[q] = tmp; } } return cur; } void match(std::string_view s) { int p = 1; for (int i = 1, cur = 0; i &lt;= int(s.length()); i++) { int d = s[i - 1] - '0'; while (p != 1 &amp;&amp; !ch[p][d]) p = link[p], cur = len[p]; if (ch[p][d]) p = ch[p][d], cur = std::min(cur + 1, len[p]); g[i] = cur; } }} gsam;std::string s;bool check(int u) { static int q[N], hd = 1, tl = 0; for (int i = 0; i &lt; u; i++) f[i] = 0; q[hd = tl = 1] = 0; for (int i = u; i &lt;= int(s.length()); i++) { f[i] = f[i - 1]; while (hd &lt;= tl &amp;&amp; f[i - u] - (i - u) &gt;= f[q[tl]] - q[tl]) tl--; q[++tl] = i - u; while (hd &lt;= tl &amp;&amp; q[hd] &lt; i - g[i]) hd++; if (hd &lt;= tl) f[i] = std::max(f[i], f[q[hd]] + i - q[hd]); } return f[s.length()] * 10u &gt;= s.length() * 9;}void solve() { std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1, lst = 1; i &lt;= m; i++, lst = 1) { std::cin &gt;&gt; s; for (auto c : s) lst = gsam.expand(lst, c - '0'); } for (int i = 1; i &lt;= n; i++) { std::cin &gt;&gt; s; int lo = 0, hi = s.length(), ans = 0; gsam.match(s); while (lo &lt;= hi) { int mid = (lo + hi) &gt;&gt; 1; if (check(mid)) lo = mid + 1, ans = mid; else hi = mid - 1; } std::cout &lt;&lt; ans &lt;&lt; \"\\n\"; }}signed main() { std::cin.tie(nullptr)-&gt;sync_with_stdio(false); int t = 1; // std::cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2024/01/21/P4022-CTSC2012-%E7%86%9F%E6%82%89%E7%9A%84%E6%96%87%E7%AB%A0/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/01/17/hello-world/"},{"title":"test","text":"Test File1234567#include &lt;iostream&gt;&lt;=&gt;===","link":"/2024/01/17/test/"},{"title":"P2178 [NOI2015] 品酒大会","text":"首先容易得知两个 相似的子串一定是 相似的，这是一个类似后缀包含的结构，我们可以很自然的联想到 SAM。 由于是后缀，因此我们考虑对反串建出 SAM，则容易知道两个后缀的最大相似度即为其对应节点在 link 树上的 LCA 的 len，也即是 LCP 的长度，根据经典套路我们可以考虑枚举 link 树上的每一个节点作为 LCA 来计算贡献。容易知道两个后缀的 LCP 对应节点为 时，后缀所对应的两个节点一定是分别位于 的不同子树内部的，因此很容易就能求出最大相似度为某一定值的后缀对数，又根据我们一开始得到的结论，我们只需要做一个后缀和就能得到相似度可以为某一个值的后缀对数。 再来考虑如何求最大值，根据上边的思路，我们只需要维护一棵子树内 的最大值、次大值、最小值、次小值即可求出答案，最后再做一个后缀 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using i64 = long long;constexpr int N = 1e6 + 50;int cnt[N];struct SAM { int ch[N][26], len[N], link[N], cnt = 1, lst = 1; int expand(char c) { int cur = ++cnt, d = c - 'a'; len[cur] = len[lst] + 1, ::cnt[cur] = 1; int p = lst; for (; p &amp;&amp; !ch[p][d]; p = link[p]) ch[p][d] = cur; if (!p) { link[cur] = 1; } else { int q = ch[p][d]; if (len[p] + 1 == len[q]) { link[cur] = q; } else { int tmp = ++cnt; len[tmp] = len[p] + 1, link[tmp] = link[q]; memcpy(ch[tmp], ch[q], sizeof(ch[tmp])); for (; p &amp;&amp; ch[p][d] == q; p = link[p]) ch[p][d] = tmp; link[cur] = link[q] = tmp; } } return lst = cur; }} sam;int n, a[N];char s[N];std::vector&lt;int&gt; adj[N];i64 sum[N];int mx[N], smx[N], mn[N], smn[N]; // `s` stands for `semi`i64 ans[N];inline void chkmax(int u, int w) { if (w &gt;= mx[u]) smx[u] = mx[u], mx[u] = w; else if (w &gt; smx[u]) smx[u] = w;}inline void chkmin(int u, int w) { if (w &lt;= mn[u]) smn[u] = mn[u], mn[u] = w; else if (w &lt; smn[u]) smn[u] = w;}void dfs(int u) { int t = 0; for (auto v : adj[u]) { dfs(v), t += cnt[v]; chkmax(u, mx[v]), chkmax(u, smx[v]); chkmin(u, mn[v]), chkmin(u, smn[v]); } if (t + cnt[u] &lt; 2) return cnt[u] += t, void(); i64 &amp;p = ans[sam.len[u]]; p = std::max({p, 1ll * mx[u] * smx[u], 1ll * mn[u] * smn[u]}); for (auto v : adj[u]) { sum[sam.len[u]] += 1ll * cnt[u] * cnt[v]; cnt[u] += cnt[v]; }}void solve() { memset(mx, -0x3f, sizeof(mx)), memset(smx, -0x3f, sizeof(mx)); memset(mn, 0x3f, sizeof(mn)), memset(smn, 0x3f, sizeof(mn)); memset(ans, -0x3f, sizeof(ans)); std::cin &gt;&gt; n &gt;&gt; (s + 1); for (int i = 1; i &lt;= n; i++) std::cin &gt;&gt; a[i]; for (int i = n; i &gt;= 1; i--) { int p = sam.expand(s[i]); mx[p] = mn[p] = a[i]; } for (int i = 2; i &lt;= sam.cnt; i++) adj[sam.link[i]].push_back(i); dfs(1); for (int i = n - 1; ~i; i--) { sum[i] += sum[i + 1]; ans[i] = std::max(ans[i], ans[i + 1]); } for (int i = 0; i &lt; n; i++) { std::cout &lt;&lt; sum[i] &lt;&lt; \" \" &lt;&lt; (sum[i] ? ans[i] : 0) &lt;&lt; \"\\n\"; }}signed main() { std::cin.tie(nullptr)-&gt;sync_with_stdio(false); int t = 1; // std::cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2024/01/22/P2178-NOI2015-%E5%93%81%E9%85%92%E5%A4%A7%E4%BC%9A/"},{"title":"P3346 [ZJOI2015] 诸神眷顾的幻想乡","text":"这东西天然构成一棵字典树，考虑建出广义 SAM 来做。 但是发现如果钦定某一个节点为根的话，则只能统计出从这个节点出发的所有串，并不能包含所有的串。但是我们注意到题目保证叶子数不超过 个，因此我们可以依次枚举每一个叶子节点作为字典树的根，然后将从这个节点出发的点全部都塞到广义 SAM 里边去，容易发现这样搞虽然可能会重，但一定不会漏，而我们求的是本质不同子串的数量，因此重复的串并不影响答案。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using i64 = long long;// 增量构造吧，直接拉出来不是很好写constexpr int N = 4e6 + 50;int n, c, a[N];std::vector&lt;int&gt; adj[N];int deg[N];struct GSAM { int ch[N][10], link[N], len[N], cnt = 1; int expand(int lst, int d) { int cur = ch[lst][d]; if (len[cur]) return cur; len[cur] = len[lst] + 1; int p = link[lst]; for (; p &amp;&amp; !ch[p][d]; p = link[p]) ch[p][d] = cur; if (!p) { link[cur] = 1; } else { int q = ch[p][d]; if (len[p] + 1 == len[q]) { link[cur] = q; } else { int tmp = ++cnt; len[tmp] = len[p] + 1, link[tmp] = link[q]; for (int i = 0; i &lt; c; i++) ch[tmp][i] = len[ch[q][i]] ? ch[q][i] : 0; for (; p &amp;&amp; ch[p][d] == q; p = link[p]) ch[p][d] = tmp; link[cur] = link[q] = tmp; } } return cur; } void build() { std::queue&lt;std::pair&lt;int, int&gt;&gt; q; for (int i = 0; i &lt; c; i++) if (ch[1][i]) q.emplace(1, i); while (!q.empty()) { auto [u, d] = q.front(); q.pop(), u = expand(u, d); for (int i = 0; i &lt; c; i++) if (ch[u][i]) q.emplace(u, i); } }} gsam;void dfs(int u, int frm, int p) { if (!gsam.ch[p][a[u]]) gsam.ch[p][a[u]] = ++gsam.cnt; p = gsam.ch[p][a[u]]; for (auto v : adj[u]) { if (v == frm) continue; dfs(v, u, p); }}void solve() { std::cin &gt;&gt; n &gt;&gt; c; for (int i = 1; i &lt;= n; i++) std::cin &gt;&gt; a[i]; for (int i = 1, u, v; i &lt; n; i++) { std::cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v), adj[v].push_back(u); deg[u]++, deg[v]++; } for (int i = 1; i &lt;= n; i++) if (deg[i] == 1) dfs(i, 0, 1); gsam.build(); i64 ans = 0; for (int i = 1; i &lt;= gsam.cnt; i++) ans += gsam.len[i] - gsam.len[gsam.link[i]]; std::cout &lt;&lt; ans &lt;&lt; \"\\n\";}signed main() { std::cin.tie(nullptr)-&gt;sync_with_stdio(false); int t = 1; // std::cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2024/01/22/P3346-ZJOI2015-%E8%AF%B8%E7%A5%9E%E7%9C%B7%E9%A1%BE%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1/"},{"title":"P2414 [NOI2011] 阿狸的打字机","text":"题意类似多模式串匹配，因此我们考虑建出 AC 自动机，然后离线下来，将询问挂到文本串对应的 AC 自动机的节点上。 然后就很好做了，我们考虑对 fail 树进行 DFS，容易得到模式串被文本串匹配的次数就是文本串对应的节点位于模式串末尾节点子树内部的个数，这个我们直接用 BIT 处理即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using i64 = long long;using pii = std::pair&lt;int, int&gt;;constexpr int N = 2e5 + 50;std::string s;int m;std::vector&lt;pii&gt; qry[N];struct ACAM { int ch[N][26], nxt[N], cnt, fa[N], end[N], to[N]; int tr[N][26]; void eval(const std::string_view &amp;s) { int p = 0, sc = 0; for (auto c : s) { if (c == 'B') { p = fa[p]; } else if (c == 'P') { end[p] = ++sc, to[sc] = p; } else { if (!ch[p][c - 'a']) ch[p][c - 'a'] = ++cnt; fa[ch[p][c - 'a']] = p, p = ch[p][c - 'a']; } } } void build() { std::queue&lt;int&gt; q; for (int i = 0; i &lt; 26; i++) { if (ch[0][i]) q.push(ch[0][i]); tr[0][i] = ch[0][i]; } while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; 26; i++) { int &amp;v = ch[u][i]; tr[u][i] = v; if (!v) v = ch[nxt[u]][i]; else nxt[v] = ch[nxt[u]][i], q.push(v); } } }} ac;int dfn[N], siz[N], clk;std::vector&lt;int&gt; adj[N];inline int in(int u) { return dfn[u]; }inline int out(int u) { return dfn[u] + siz[u] - 1; }void dfs(int u) { dfn[u] = ++clk, siz[u] = 1; for (auto v : adj[u]) dfs(v), siz[u] += siz[v];}struct BIT { int tree[N]; void modify(int u, int val) { for (int i = u; i &lt;= clk; i += i &amp; -i) tree[i] += val; } int query(int u) { int res = 0; for (int i = u; i; i -= i &amp; -i) res += tree[i]; return res; } int query(int l, int r) { return query(r) - query(l - 1); }} bit;int ans[N];void calc(int u) { bit.modify(dfn[u], 1); if (ac.end[u]) { for (auto [x, i] : qry[ac.end[u]]) { ans[i] = bit.query(in(ac.to[x]), out(ac.to[x])); } } for (int i = 0; i &lt; 26; i++) { if (!ac.tr[u][i]) continue; calc(ac.tr[u][i]); } bit.modify(dfn[u], -1);}void solve() { std::cin &gt;&gt; s; ac.eval(s), ac.build(); for (int i = 1; i &lt;= ac.cnt; i++) adj[ac.nxt[i]].push_back(i); dfs(0); std::cin &gt;&gt; m; for (int i = 1, x, y; i &lt;= m; i++) { std::cin &gt;&gt; x &gt;&gt; y; qry[y].emplace_back(x, i); } calc(0); for (int i = 1; i &lt;= m; i++) std::cout &lt;&lt; ans[i] &lt;&lt; &quot;\\n&quot;;}signed main() { std::cin.tie(nullptr)-&gt;sync_with_stdio(false); int t = 1; // std::cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2024/01/22/P2414-NOI2011-%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA/"}],"tags":[{"name":"SAM","slug":"SAM","link":"/tags/SAM/"},{"name":"虚树","slug":"虚树","link":"/tags/%E8%99%9A%E6%A0%91/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"ACAM","slug":"ACAM","link":"/tags/ACAM/"},{"name":"BIT","slug":"BIT","link":"/tags/BIT/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Other","slug":"Other","link":"/categories/Other/"},{"name":"Codeforces","slug":"题解/Codeforces","link":"/categories/%E9%A2%98%E8%A7%A3/Codeforces/"},{"name":"Luogu","slug":"题解/Luogu","link":"/categories/%E9%A2%98%E8%A7%A3/Luogu/"}],"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}