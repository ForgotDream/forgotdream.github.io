{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/01/17/hello-world/"},{"title":"test","text":"Test File1234567#include &lt;iostream&gt;&lt;=&gt;===","link":"/2024/01/17/test/"},{"title":"P4022 [CTSC2012] 熟悉的文章","text":"感觉完全没有黑啊？不知道怎么评出来的。 首先答案显然是可以二分的，我们考虑二分出一个答案之后怎么做。 对于这类问题我们是很容易建出 DP 的模型的。我们设 为 为当前已经决策到了第 个字符时所能得到的最大的段的总长。那么这个 DP 的转移就比较显然了。 可以注意到有两种决策。第一种是当前字符不被选入某一段中，那么就有 。另一种是将当前划入某一段中，枚举这一段的开头 ，则有 ，当然 是有选取范围的，设当前二分的答案为 ，且 在原串中最多往前匹配 位，则有 。这样就可以容易的做到 的时间复杂度了，其中 为当前询问字符串的长度。 考虑如何优化。容易发现，内层的 DP 是一个比较显然的滑动窗口的模型，因此我们直接套用一个单调队列来优化即可，这样 DP 部分就可以做到 了。 然后再来考虑怎么求这个 。这个当然是比较简单的，我们把原串组织成一棵广义 SAM，那么求 len 的过程就类似于使用 SAM 求 LCS 的过程，我们直接跳 link 树即可。这部分的时间复杂度为 的。 于是这样这道题就做完了！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using i64 = long long;constexpr int N = 2e6 + 50;int n, m;int f[N], g[N];struct GSAM { int ch[N][2], len[N], link[N], cnt = 1; int expand(int lst, int d) { int p = lst; if (int q = ch[p][d]) { if (len[p] + 1 == len[q]) { return q; } else { int tmp = ++cnt; len[tmp] = len[p] + 1, link[tmp] = link[q]; memcpy(ch[tmp], ch[q], sizeof(ch[tmp])); for (; p &amp;&amp; ch[p][d] == q; p = link[p]) ch[p][d] = tmp; link[q] = tmp; return tmp; } } int cur = ++cnt; len[cur] = len[p] + 1; for (; p &amp;&amp; !ch[p][d]; p = link[p]) ch[p][d] = cur; if (!p) { link[cur] = 1; } else { int q = ch[p][d]; if (len[p] + 1 == len[q]) { link[cur] = q; } else { int tmp = ++cnt; len[tmp] = len[p] + 1, link[tmp] = link[q]; memcpy(ch[tmp], ch[q], sizeof(ch[tmp])); for (; p &amp;&amp; ch[p][d] == q; p = link[p]) ch[p][d] = tmp; link[cur] = link[q] = tmp; } } return cur; } void match(std::string_view s) { int p = 1; for (int i = 1, cur = 0; i &lt;= int(s.length()); i++) { int d = s[i - 1] - '0'; while (p != 1 &amp;&amp; !ch[p][d]) p = link[p], cur = len[p]; if (ch[p][d]) p = ch[p][d], cur = std::min(cur + 1, len[p]); g[i] = cur; } }} gsam;std::string s;bool check(int u) { static int q[N], hd = 1, tl = 0; for (int i = 0; i &lt; u; i++) f[i] = 0; q[hd = tl = 1] = 0; for (int i = u; i &lt;= int(s.length()); i++) { f[i] = f[i - 1]; while (hd &lt;= tl &amp;&amp; f[i - u] - (i - u) &gt;= f[q[tl]] - q[tl]) tl--; q[++tl] = i - u; while (hd &lt;= tl &amp;&amp; q[hd] &lt; i - g[i]) hd++; if (hd &lt;= tl) f[i] = std::max(f[i], f[q[hd]] + i - q[hd]); } return f[s.length()] * 10u &gt;= s.length() * 9;}void solve() { std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1, lst = 1; i &lt;= m; i++, lst = 1) { std::cin &gt;&gt; s; for (auto c : s) lst = gsam.expand(lst, c - '0'); } for (int i = 1; i &lt;= n; i++) { std::cin &gt;&gt; s; int lo = 0, hi = s.length(), ans = 0; gsam.match(s); while (lo &lt;= hi) { int mid = (lo + hi) &gt;&gt; 1; if (check(mid)) lo = mid + 1, ans = mid; else hi = mid - 1; } std::cout &lt;&lt; ans &lt;&lt; \"\\n\"; }}signed main() { std::cin.tie(nullptr)-&gt;sync_with_stdio(false); int t = 1; // std::cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2024/01/21/P4022-CTSC2012-%E7%86%9F%E6%82%89%E7%9A%84%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"test","slug":"test","link":"/tags/test/"},{"name":"SAM","slug":"SAM","link":"/tags/SAM/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"}],"categories":[{"name":"Other","slug":"Other","link":"/categories/Other/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"}],"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}